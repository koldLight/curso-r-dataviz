---
title: "SMD - Visualización de datos - Webinar 1"
author: "Luz Frias"
date: "2020-10-14"
output:
  html_document:
    highlight: tango
    theme: flatly
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "..")
```

## Introducción

Estas son las soluciones a los fastbooks 1 y 2. Algunas aclaraciones:

* Este documento está con encoding UTF-8. Si lo abres desde windows, es posible que veas mal los caracteres especiales (tildes, eñes, ...). Lo puedes arreglar, en RStudio, haciendo click en File / Reopen with encoding y eligiendo UTF-8
* Las rutas a los ficheros suponen que, en la misma carpeta en la que tienes este documento, está `dat/` con los archivos de datos necesarios. Si no te funciona, es que los tienes en otra parte y tendrás que modificar esas rutas.

```{r, message=FALSE}
library(dplyr)
library(ggplot2)
library(palmerpenguins)
```

## Fastbook 1 - Gráficos estáticos com ggplot: nivel básico

### Actividad 1

Abre [colorbrewer](http://colorbrewer2.org/) y elige una paleta de colores para representar estos tres gráficos sobre el mapa que muestran de ejemplo. Para elegir una correcta, piensa en la naturaleza de los datos (secuenciales, divergentes o cualitativos):

1. El nivel de contaminación por región: **secuencial**
2. Cambio relativo en el número de habitantes con respecto a la última decada (p.e. -5%, +10%, ...): **divergente**
3. La etnia predominante por región: **cualitativa**

### Actividad 2

Examina el dataset `diamonds`, incluido dentro de la librería de `ggplot2`. Consulta la ayuda con `?diamonds` y examina su contenido.

Pinta la relación en un gráfico de puntos del precio frente a los quilates.

```{r}
# opcional, toco el alpha (opacidad) para que se vean mejor los puntos superpuestos
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point(alpha = 0.2)
```

### Actividad 3

Con el dataset `penguins`:

1. Pinta la relación entre longitud y profundidad del pico (bill).

```{r}
ggplot(data = penguins) +
  geom_point(mapping = aes(x = bill_length_mm, y = bill_depth_mm))
```

2. Añade al gráfico del punto 1 la distinción entre especies mediante el color.

```{r}
ggplot(data = penguins) +
  geom_point(mapping = aes(x = bill_length_mm, y = bill_depth_mm, color = species))
```

3. Añade al gráfico del punto 1 la distinción entre el peso corporal mediante el color.

```{r}
ggplot(data = penguins) +
  geom_point(mapping = aes(x = bill_length_mm, y = bill_depth_mm, color = body_mass_g))
```

4. ¿Qué observas en las escalas de color que ha utilizado ggplot en cada uno de los dos casos? ¿De qué naturaleza (secuencial, divergente o cualitativa) es cada una de ellas? ¿Por qué crees que ha hecho esto por defecto?

Respuesta: para `species` se utiliza una escala cualitativa, para `body_mass_g` se utiliza una secuencial. Es por el tipo de dato: para datos factor / cadenas de caracters / booleanos, ggplot utiliza por defecto escalas cualitativas. Para numéricos, ggplot utiliza escalas secuenciales.

### Actividad 4

1. Lee los datos del economista (dat/economist.csv), con indicadores de desarrollo y corrupción por países:

* HDI: Human Development Index (1: más desarrollado)
* CPI: Corruption Perception Index (10: menos corrupto)

2. Crea un gráfico que:

* Cada país sea un punto
* El eje x indique CPI, el y HDI
* El color del punto indique la región
* Su tamaño sea proporcional al ranking HDI

3. ¿Qué conclusiones extraes del gráfico?

```{r}
economist <- read.csv("dat/economist.csv")

ggplot(economist) +
  geom_point(aes(x = CPI, y = HDI, color = Region, size = HDI.Rank))
```

### Actividad 5

1. Lee los datos de los resultados de las elecciones presidenciales de los Estados Unidos (dat/usa_president.csv). Puedes consultar más información sobre este dataset [aquí](https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/42MVDX).

2. Pinta en un gráfico de líneas la evolución del número de votos a lo largo de los años del partido republicado frente al demócrata.

> Ten en cuenta que tendrás que hacer una transformación de los datos antes de pintarlos. Razona en qué formato necesitas el dataframe y aplica las operaciones necesarias antes de utilizar ggplot.

```{r}
# Lectura del dataset
usa_president <- read.csv("dat/usa_president.csv")

# Agrupo para los partidos de interés, por año y partido
usa_president_by_year <- usa_president %>%
  filter(party %in% c("democrat", "republican")) %>%
  group_by(year, party) %>%
  summarise(candidatevotes = sum(candidatevotes))

# Pinto las líneas por cada partido
ggplot(usa_president_by_year) +
  geom_line(aes(x = year, y = candidatevotes, color = party))
```

## Fastbook 2 - Gráficos estáticos con ggplot: nivel intermedio

### Actividad 1

Rescata el gráfico que hiciste en el fastbook anterior, pero añadiendo el tercer punto aquí detallado.

1. Lee los datos del economista (dat/economist.csv), con indicadores de desarrollo y corrupción por países:

* HDI: Human Development Index (1: más desarrollado)
* CPI: Corruption Perception Index (10: menos corrupto)

2. Crea un gráfico que:

* Cada país sea un punto
* El eje `x` indique CPI, el `y` HDI
* El color del punto indique la región
* Su tamaño sea proporcional al ranking HDI

3. Pinta una línea de tendencia que muestre la relación entre el CPI y el HDI (entre el eje `x` y el eje `y`)

```{r}
# Fíjate en el mapeo "común", en ggplot, y el mapeo "específico", en geom_point
# Además, de forma opcional, he personalizado la escala de colores por una que
#  distingue mejor las categorías
ggplot(economist, aes(x = CPI, y = HDI)) +
  geom_point(aes(color = Region, size = HDI.Rank)) +
  scale_color_brewer(palette = "Dark2") +
  geom_smooth()
```

### Actividad 2

1. Lee los datos de las elecciones presidenciales de EEUU (dat/usa_president.csv)

2. Quédate únicamente con los datos de las elecciones de 2016, con los resultados de los partidos demócrata y republicano, y con las filas con writein = FALSE (fe de erratas: en la versión original del fastbook viene TRUE en lugar de FALSE).

3. Quédate con el número de votos demócratas y republicanos para cada estado.

4. Pinta un gráfico de barras apiladas. Bonus: ordénalo por total de votos

```{r}
# Transformación previa
usa_elections <- usa_president %>%
  filter(year == 2016, party %in% c("democrat", "republican"), !writein) %>%
  arrange(totalvotes)

# Mi paleta de colores
# También podría utilizar códigos hexadecimales, como p.e.
# palette <- c("democrat" = "#4575b4", "republican" = "#d73027")
palette <- c("democrat" = "blue", "republican" = "red")

# Forma 1 para ordenar las barras: reorder
ggplot(usa_elections) +
  geom_col(aes(y = reorder(state_po, totalvotes), x = candidatevotes, fill = party)) +
  scale_fill_manual(values = palette)

# Forma 2 para ordenar las barras: cambiar el orden del factor
states <- unique(usa_elections$state_po)
usa_elections$state_po <- factor(usa_elections$state_po, levels = states)

# Con scale_xxx_manual defino mi propia paleta de colores
ggplot(usa_elections) +
  geom_col(aes(y = state_po, x = candidatevotes, fill = party)) +
  scale_fill_manual(values = palette)
```

### Actividad 3

1. Lee los datos de las elecciones presidenciales de EEUU (dat/usa_president.csv)

2. Como antes, quédate únicamente con los datos de las elecciones de 2016, con los resultados de los partidos demócrata y republicano, y con las filas con writein = TRUE (fe de erratas: en la versión original del fastbook viene TRUE en lugar de FALSE).

3. Calcula para cada estado, una columna nueva que se llame `rep_preference` definida como `(votos_republicanos / (votos_republicanos + votos_democratas) - 0.5) * 2` . Esta columna tendrá valores cercanos al 0 para estados donde hubo un resultado cercano al empate, acercándose al 1 si ganaron los republicanos y acercándose al -1 si ganaron los demócratas. Nota: puede que te resulte útil separar los datos en dos datasets (votos republicanos y votos demócratas) y luego unirlos.

4. Pinta un gráfico de puntos, en el eje `y` el estado (la abreviatura de dos caracteres) y en el eje `x` el valor de `republican_preference`. El color del punto será una escala divergente, en la que a mayor victoria republicana sea más rojo (valor más positivo), mayor victoria demócrata más azul (valor más negativo), y los cercanos al empate sean blancos o amarillos (valor más cercano al cero).

8. Ordena los estados por `rep_preference` y centra el 0 en mitad del gráfico.

9. Centra el cero en mitad del eje x

10. Centra el cero en el valor neutro de la escala de colores

```{r}
# Separo los dataframes en dos: votos rep y votos dem
rep_votes <- usa_elections %>%
  filter(party == "republican") %>%
  select(state_po, candidatevotes)
dem_votes <- usa_elections %>%
  filter(party == "democrat") %>%
  select(state_po, candidatevotes)

# Los cruzo, para tener los votos de ambos en la misma fila
votes <- dem_votes %>%
  inner_join(rep_votes, by = "state_po", suffix = c("_dem", "_rep")) %>%
  mutate(
    rep_preference = (candidatevotes_rep / (candidatevotes_rep + candidatevotes_dem) - 0.5) * 2
  ) %>%
  arrange(rep_preference)

# Gracias a limits centro, tanto la escala de color, como la del eje x
# Con scale_xxxx_distiller transformo una escala de colorbrewer, pensada para un
# número pequeño de categorías, en una escala continua, interpolando los valores
# intermedios. Consulta la ayuda para más opciones
ggplot(votes) +
  geom_point(aes(y = reorder(state_po, rep_preference), x = rep_preference, color = rep_preference)) +
  scale_color_distiller(palette = "RdYlBu", limits = c(-1, 1)) +
  scale_x_continuous(limits = c(-1, 1))
```

> Consulta la ayuda de `?scale_colour_brewer`, especialmente para qué sirve la variación `_distiller`.

### Actividad libre

Coge algún dataset de tu interés (por ejemplo, alguno de los que hemos usado hasta ahora: `diamonds`, `penguins`, ... o de otra asignatura) y explóralo mediante gráficos: histogramas, gráficos de puntos, barras, ...

