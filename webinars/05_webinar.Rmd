---
title: "SMD - Visualización de datos - Webinar 5"
author: "Luz Frias"
date: "2020-11-24"
output:
  html_document:
    highlight: tango
    theme: flatly
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
library(dplyr)
library(tidyr)
library(shiny)
library(palmerpenguins)
library(plotly)
library(leaflet)
library(DT)
library(sf)
```

## Introducción

Estas son las soluciones a los fastbooks 9 y 10.

Algunas aclaraciones:

* Este documento está con encoding UTF-8. Si lo abres desde windows, es posible que veas mal los caracteres especiales (tildes, eñes, ...). Lo puedes arreglar, en RStudio, haciendo click en File / Reopen with encoding y eligiendo UTF-8
* Las rutas a los ficheros suponen que, en la misma carpeta en la que tienes este documento, está `dat/` con los archivos de datos necesarios. Si no te funciona, es que los tienes en otra parte y tendrás que modificar esas rutas.

## Fastbook 9 - Flexdashboard

### Actividad 1

Crea una aplicación, utilizando el dataset de los pingüinos, que tenga:

* Como inputs, unos _radio buttons_ para elegir el sexo.
* Como outputs: 

    * Un gráfico de puntos de _plotly_ mostrando en el eje x el peso, y en el eje y la longitud de la aleta, y con un color diferente por especie, solo para el sexo escogido.
    * Una _datatable_ paginada con el detalle de especie, sexo, peso y longitud de la aleta, para el sexo escogido.

```{r}
# La interfaz gráfica
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      radioButtons(
        inputId = "sex",
        label   = "Sexo",
        choices = c("female", "male")
      )
    ),
    
    mainPanel(
      plotlyOutput(outputId = "chart"),
      dataTableOutput(outputId = "table")
    )
  )
)

# El servidor
server <- function(input, output) {
  
  output$chart <- renderPlotly({
    tmp <- filter(penguins, !is.na(sex), sex == input$sex)
    plot_ly(tmp, type = "scatter", mode = "markers",
            x = ~body_mass_g, y = ~flipper_length_mm)
  })
  
  output$table <- renderDataTable({
    penguins %>%
      filter(!is.na(sex), sex == input$sex) %>%
      select(species, sex, body_mass_g, flipper_length_mm)
  })
}

# Generamos la aplicación
shinyApp(ui = ui, server = server)
```

### Actividad 2

Crea una aplicación de shiny para visualizar las líneas y paradas del metro de Madrid sobre un mapa interactivo.

Tienes disponible los datos en `dat/lineas_metro.geojson` y `dat/paradas_metro_madrid.geojson`.

La aplicación tendrá:

* Como inputs, el listado de líneas disponibles.
* Como output, un mapa de `leaflet` mostrando la línea y sus paradas sobre Madrid.

```{r}
lineas_metro  <- read_sf("dat/lineas_metro.geojson")
lineas_select <- lineas_metro$Linea
names(lineas_select) <- lineas_metro$Texto

# La interfaz gráfica
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      selectInput(
        inputId = "linea",
        label   = "Línea",
        choices = lineas_select
      )
    ),
    
    mainPanel(
      leafletOutput(outputId = "map")
    )
  )
)

# El servidor
server <- function(input, output) {
  
  paradas_metro <- read_sf("dat/paradas_metro_madrid.geojson")
  lineas_metro  <- read_sf("dat/lineas_metro.geojson")
  
  colores_lineas <- c(
    "L1"    = "#38a3dc",
    "L2"    = "#f40104",
    "L3"    = "#fbe115",
    "L4"    = "#944247",
    "L5"    = "#96bf0e",
    "L6"    = "#9fa4a6",
    "L7"    = "#f7a64b",
    "L8"    = "#f500ff",
    "L9"    = "#a3228d",
    "L10"   = "#174594",
    "L11"   = "#185b00",
    "L12"   = "#a49a00",
    "Ramal" = "#090080"
  )
  
  paleta_lineas <- colorFactor(
    palette = unname(colores_lineas),
    levels  = names(colores_lineas)
  )
  
  output$map <- renderLeaflet({
    # Filtros
    tmp_lineas <- lineas_metro %>%
      filter(Linea == input$linea)
    tmp_paradas <- paradas_metro %>%
      filter(line == input$linea)
    
    leaflet(tmp_lineas) %>%
      addProviderTiles("CartoDB.Positron") %>%
      setView(lng = -3.69, lat = 40.43, zoom = 12) %>%
      addPolylines(data = tmp_lineas, color = ~paleta_lineas(Linea), opacity = 0.8) %>%
      addCircleMarkers(data = tmp_paradas, stroke = FALSE, radius = 5, fillOpacity = 0.5) %>%
      addLegend(
        position = "bottomright",
        pal      = paleta_lineas,
        values   = ~Linea,
        title    = "Línea"
      )
  })
  
}

# Generamos la aplicación
shinyApp(ui = ui, server = server)
```

## Fastbook 9 - Flexdashboard

### Actividad 1

Partiendo del ejemplo `examples/02_fibonacci_con_conductor`, añade un botón al menú lateral y cambia la implementación para que los resultados se actualicen al pulsarlo, y no al cambiar el parámetro de entrada.

```{r}
# Función para calcular el enésimo número de la serie de fibonacci
fibonacci <- function(n) {
  if (n < 1) {
    return(NA)
  }
  if (n < 3) {
    return(1)
  }
  fibonacci(n - 1) + fibonacci(n - 2)
}


# La interfaz gráfica
ui <- fluidPage(
  
  # El título de la aplicación
  titlePanel("Serie de Fibonacci"),
  
  # Un panel que tiene una zona más pequeña en el lateral izquierdo,
  # y un panel principal más grande a la derecha
  sidebarLayout(
    
    # Usaremos el panel izquierdo para los inputs
    sidebarPanel(
      
      # Input de tipo slide
      numericInput(inputId   = "numero",
                   label     = h3("Número"),
                   value     = 10,
                   min       = 1,
                   max       = 30),
      
      # El botón
      actionButton(inputId = "boton", label = "Calcular")
    ),
    
    # El panel principal con los outputs
    mainPanel(
      
      h4("Serie: ", textOutput(outputId = "serie")),
      h4("Suma: ",  textOutput(outputId = "suma")),
      h4("Media: ", textOutput(outputId = "media")),
      
    )
  )
)

# El servidor
server <- function(input, output) {
  
  # El conductor, que devuelve la serie.
  # Hay que encapsularlo dentro de una expresión en la función reactive
  serie <- reactive({
    input$boton
    numero <- isolate(input$numero)
    sapply(1:numero, fibonacci)
  })
  
  # El output serie contiene toda la serie
  output$serie <- renderText({
    paste(serie(), collapse = ", ")
  })
  
  # El output suma contiene toda la suma de todos los valores de la serie
  output$suma <- renderText({
    sum(serie())
  })
  
  # El output media contiene toda la media de todos los valores de la serie
  output$media <- renderText({
    mean(serie())
  })
  
}

# Generamos la aplicación
shinyApp(ui = ui, server = server)
```

### Actividad 2

Crea una aplicación de shiny para visualizar el porcentaje de voto a cada uno de los partidos en las últimas elecciones.

La aplicación tendrá:

* Como inputs, el listado de partidos disponibles.
* Como outputs:

    * Un mapa de `leaflet` mostrando las provincias, coloreadas según el porcentaje de voto (es decir, los votos a ese partido / los votos válidos en la provincia) obtenido en cada una de ellas. Incluye una leyenda para poder interpretarlo fácilmente.
    * Un gráfico de barras de `plotly` mostrando el número de votos por provincia, ordenado de mayor a menor número de votos.
    
La función de tratamiento y filtrado de los datos para obtener el número de votos (absoluto y porcentual) por provincia al partido seleccionado deberá ejecutarse una única vez, y no repetirse para cada salida.

```{r}

# La interfaz gráfica
ui <- fluidPage(
  
  titlePanel("Elecciones España"),
  
  sidebarLayout(
    
    sidebarPanel(
      
      selectInput(
        inputId = "partido",
        label   = "Partido",
        choices = c("psoe", "pp", "vox", "podemos")
      )
    ),
    
    mainPanel(
      leafletOutput("map"),
      plotlyOutput("chart")
    )
  )
)

# El servidor
server <- function(input, output) {
  
  provincias <- read_sf("dat/spain_provinces.geojson")
  elecciones <- read.csv("dat/elecciones_2019_provincias.csv")
  votos <- read.csv("dat/elecciones_2019_votos.csv")
  
  colores <- c("psoe" = "Reds", "pp" = "Blues", "vox" = "Greens", "podemos" = "Purples")
  
  # Procesamiento de datos
  datos <- reactive({
    votos %>%
      filter(partido == input$partido) %>%
      inner_join(elecciones) %>%
      mutate(ratio_votos = round(votos / votos_validos, 3)) %>%
      select(provincia_cod_ine, provincia_nombre, votos, ratio_votos)
  })
  
  # El output serie contiene toda la serie
  output$map <- renderLeaflet({
    # Recupero los datos ya procesados del conductor
    votos <- datos()
    
    # Provincias con su info geográfica
    mapa_votos <- provincias %>%
      left_join(votos, by = c("codigo" = "provincia_cod_ine"))
    
    # Leyenda
    pal_votos <- colorBin(
      palette = colores[input$partido],
      domain  = mapa_votos$ratio_votos,
      bins    = 5
    )
    
    # Mapa
    leaflet(mapa_votos) %>%
      addPolygons(
        color       = ~pal_votos(ratio_votos),
        stroke      = FALSE,
        fillOpacity = 1) %>%
      addLegend(
        position = "bottomright",
        pal      = pal_votos,
        values   = ~ratio_votos,
        title    = "% votos",
        labFormat = labelFormat(suffix = "%", transform = function(x) 100 * x),
      )
  })
  
  # El output suma contiene toda la suma de todos los valores de la serie
  output$chart <- renderPlotly({
    # Recupero los datos ya procesados del conductor
    votos <- datos()
    
    # Ordeno por número de votos
    votos <- arrange(votos, votos)
    votos$provincia_nombre <- factor(votos$provincia_nombre, levels = votos$provincia_nombre)
    plot_ly(votos, type = "bar", x = ~votos, y = ~provincia_nombre, height = 1200)
  })
  
}

# Generamos la aplicación
shinyApp(ui = ui, server = server)
```

### Actividad 3

Como comentamos en el _fastbook_ anterior, una aplicación de Shiny necesita de un servidor que esté continuamente corriendo la aplicación, contestando a las peticiones de los usuarios. Lee en [este link](https://shiny.rstudio.com/tutorial/written-tutorial/lesson7/) las diferentes opciones que hay para desplegar aplicaciones en Shiny. Créate una cuenta gratuita en Shinyapps.io y despliega la aplicación de la actividad 2 siguiendo [este tutorial](https://shiny.rstudio.com/articles/shinyapps.html).

