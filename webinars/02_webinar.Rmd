---
title: "SMD - Visualización de datos - Webinar 2"
author: "Luz Frias"
date: "2020-10-22"
output:
  html_document:
    highlight: tango
    theme: flatly
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "..")
```

## Introducción

Estas son las soluciones a los fastbooks 3 y 4. Algunas aclaraciones:

* Este documento está con encoding UTF-8. Si lo abres desde windows, es posible que veas mal los caracteres especiales (tildes, eñes, ...). Lo puedes arreglar, en RStudio, haciendo click en File / Reopen with encoding y eligiendo UTF-8
* Las rutas a los ficheros suponen que, en la misma carpeta en la que tienes este documento, está `dat/` con los archivos de datos necesarios. Si no te funciona, es que los tienes en otra parte y tendrás que modificar esas rutas.

```{r, message=FALSE}
library(dplyr)
library(ggplot2)
library(sf)
library(leaflet)
library(tidyr)
```

## Fastbook 3 - Gráficos estáticos con ggplot: nivel avanzado

### Actividad 1

Sobre el dataset `diamonds`, pinta:

* El histograma del precio según los _facets_ de la calidad del corte (`cut`)
* Un gráfico de barras por claridad (`clarity`) según los _facets_ de calidad del corte (`cut`) y color (`color`).

```{r}
# histograma del precio según la calidad del corte
ggplot(diamonds, aes(x = price)) +
  geom_histogram(bins = 30) +
  facet_wrap(~ cut, scales = "free_y") +
  theme_minimal() +
  labs(
    title = "Relación entre el precio y la calidad",
    y = "# diamantes",
    x = "precio"
  )
```

```{r}
# gráfico de barras por claridad según la calidad del corte y color
ggplot(diamonds, aes(x = clarity)) +
  geom_bar() +
  facet_grid(cut ~ color, scales = "free_y") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  labs(
    y = "# diamantes",
    x = "Claridad",
    title = "Diamantes por color, calidad y claridad"
  )
```

### Actividad 2

Utilizando los datos de elecciones (elecciones_2019_provincias.csv y elecciones_2019_votos.csv) y el mapa base con las provincias (spain_provinces.geojson), crea los siguientes gráficos:

1. Un mapa coloreado según la población de cada provincia (mayor intensidad = mayor población).
2. Un mapa con el color del partido más votado en cada provincia (PP en azul, PSOE en rojo, ...).
3. Un _facet_ de mapas, con 4, marcando el porcentaje de votos a los 4 partidos políticos (PP, PSOE, VOX, Podemos). Por ejemplo, en el facet del PSOE, se verán en un color más intenso las provincias con mayor % de votos a PSOE, y menos aquellas con menor %. Y así con cada uno de los partidos.

```{r}
# mapa coloreado según la población de cada provincia
provincias <- read_sf("dat/spain_provinces.geojson")
elecciones_provincias <- read.csv("dat/elecciones_2019_provincias.csv")

tmp <- provincias %>%
  inner_join(elecciones_provincias, by = c("codigo" = "provincia_cod_ine"))

ggplot(tmp) +
  geom_sf(aes(fill = poblacion)) +
  scale_fill_continuous(trans = "reverse") +
  theme_void() +
  labs(
    title = "Población por provincias",
    fill  = "Población"
  )
```

```{r}
# mapa con el color del partido más votado en cada provincia
elecciones_votos <- read.csv("dat/elecciones_2019_votos.csv")

mas_votado <- elecciones_votos %>%
  group_by(provincia_cod_ine) %>%
  arrange(desc(votos)) %>%
  summarise(partido = first(partido))

tmp <- provincias %>%
  inner_join(mas_votado, by = c("codigo" = "provincia_cod_ine"))

paleta_partidos <- c(
  "erc"          = "#f7a003",
  "navarra_suma" = "#444444",
  "pnv"          = "#278347",
  "pp"           = "#3caee1",
  "psoe"         = "#bb0201",
  "teruelexiste" = "#eeeeee",
  "vox"          = "#83b431"
)

ggplot(tmp) +
  geom_sf(aes(fill = partido)) +
  scale_fill_manual(values = paleta_partidos) +
  theme_void() +
  labs(
    title = "Partido más votado por provincia",
    fill  = "Partido"
  )
```

```{r}
# Un _facet_ de mapas, con 4, marcando el porcentaje de votos a los 4 partidos políticos
# (PP, PSOE, VOX, Podemos)

votos <- elecciones_votos %>%
  filter(partido %in% c("pp", "psoe", "podemos", "vox")) %>%
  inner_join(elecciones_provincias) %>%
  mutate(ratio_votos = votos / votos_validos)

tmp <- provincias %>%
  inner_join(votos, by = c("codigo" = "provincia_cod_ine"))

ggplot(tmp) +
  geom_sf(aes(fill = ratio_votos)) +
  scale_fill_distiller(palette = "Blues", trans = "reverse") +
  facet_wrap(~ partido) +
  theme_void()
```

### Actividad 3

Repasa estos gráficos que acabas de generar y añade títulos, nombres de eje, y personaliza el tema utilizado.


```{r}
# Hecho sobre los propios gráficos
```


## Fastbook 4 - Mapas interactivos con leaflet

### Actividad 1

Pinta el metro de Madrid, con:

* Las paradas
* Las líneas de metro, cada una con un color diferente.

_Nota_: No vale crear una capa por línea diferente de metro, todas las líneas deben ir en la misma.

_Bonus_: personaliza los colores con el suyo oficial (línea 2 en rojo, línea 7 en naranja, ...)

```{r}
paradas_metro <- read_sf("dat/paradas_metro_madrid.geojson")
lineas_metro  <- read_sf("dat/lineas_metro.geojson")

colores_lineas <- c(
  "L1"    = "#38a3dc",
  "L2"    = "#f40104",
  "L3"    = "#fbe115",
  "L4"    = "#944247",
  "L5"    = "#96bf0e",
  "L6"    = "#9fa4a6",
  "L7"    = "#f7a64b",
  "L8"    = "#f500ff",
  "L9"    = "#a3228d",
  "L10"   = "#174594",
  "L11"   = "#185b00",
  "L12"   = "#a49a00",
  "Ramal" = "#090080"
)

# Cuidado, no confundas domain y levels. levels respeta el orden,
# domain no
paleta_lineas <- colorFactor(
  palette = unname(colores_lineas),
  levels  = names(colores_lineas)
)

leaflet(lineas_metro) %>%
  addProviderTiles("CartoDB.Positron") %>%
  setView(lng = -3.69, lat = 40.43, zoom = 12) %>%
  addPolylines(data = lineas_metro, color = ~paleta_lineas(Linea), opacity = 0.8) %>%
  addCircleMarkers(data = paradas_metro, stroke = FALSE, radius = 5, fillOpacity = 0.5) %>%
  addLegend(
    position = "bottomright",
    pal      = paleta_lineas,
    values   = ~Linea,
    title    = "Línea"
  )
```

### Actividad 2

Reproduce un mapa con el % de voto a cada uno de los 4 principales partidos por Comunidad Autónoma, en lugar de por provincia.

Necesitarás, además de los datos que ya hemos ido usando en este fastbook, los siguientes:

* `dat/provincias_ccaas.csv`: con el detalle de qué provincia pertenece a cada comunidad autónoma (mediante sus códigos INE).
* `dat/spain_ccaas.geojson`: con el geojson de las comunidades autónomas simplificado

```{r}
# Código adaptado del ejemplo por provincias del fastbook
# Lectura de geojson
mapa_ccaas <- read_sf("dat/spain_ccaas.geojson")

# Lectura de datos
elecciones <- read.csv("dat/elecciones_2019_provincias.csv")
votos <- read.csv("dat/elecciones_2019_votos.csv")
prov_ccaa <- read.csv("dat/provincias_ccaas.csv")

votos_partidos <- votos %>%
  mutate(
    partido = ifelse(partido %in% c("encomupodem", "podemos_encomun"), "podemos", partido),
    partido = ifelse(partido == "navarra_suma", "pp", partido),
  ) %>%
  filter(partido %in% c("psoe", "pp", "vox", "podemos")) %>%
  inner_join(elecciones, by = "provincia_cod_ine") %>%
  inner_join(prov_ccaa, by = c("provincia_cod_ine" = "cod_ine_provincia")) %>%
  group_by(cod_ine_ccaa, partido) %>%
  summarise(
    votos = sum(votos),
    votos_validos = sum(votos_validos)
  ) %>%
  mutate(ratio_votos = round(votos / votos_validos, 3)) %>%
  select(cod_ine_ccaa, partido, ratio_votos)

# Nos viene mejor pasarlo a formato ancho, con una columna por partido
votos_partidos_ancho <- votos_partidos %>%
  pivot_wider(names_from = partido, values_from = ratio_votos)

mapa_votos <- mapa_ccaas %>%
  inner_join(votos_partidos_ancho, by = c("codigo" = "cod_ine_ccaa"))

# Las paletas, también rescatadas del fastbook
pal_votos_psoe <- colorBin(
  palette = "Reds",
  domain  = mapa_votos$psoe,
  bins    = 5
)

pal_votos_pp <- colorBin(
  palette = "Blues",
  domain  = mapa_votos$pp,
  bins    = 5
)

pal_votos_vox <- colorBin(
  palette = "Greens",
  domain  = mapa_votos$vox,
  bins    = 5
)

pal_votos_podemos <- colorBin(
  palette = "Purples",
  domain  = mapa_votos$vox,
  bins    = 5
)

# Pinto el mapa, con una capa por ratio de votos a ese partido
leaflet(data = mapa_votos) %>%
  # Capa del PSOE
  addPolygons(color       = ~pal_votos_psoe(psoe),
              label       = ~nombre,
              stroke      = FALSE,
              fillOpacity = 1,
              group       = "PSOE"
  ) %>%
  # Capa del PP
  addPolygons(color       = ~pal_votos_pp(pp),
              label       = ~nombre,
              stroke      = FALSE,
              fillOpacity = 1,
              group       = "PP"
  ) %>%
  # Capa de VOX
  addPolygons(color       = ~pal_votos_vox(vox),
              label       = ~nombre,
              stroke      = FALSE,
              fillOpacity = 1,
              group       = "VOX"
  ) %>%
  # Capa de Podemos
  addPolygons(color       = ~pal_votos_podemos(podemos),
              label       = ~nombre,
              stroke      = FALSE,
              fillOpacity = 1,
              group       = "Podemos"
  ) %>%
  # Control de capas
  addLayersControl(
    baseGroups = c("PSOE", "PP", "VOX", "Podemos"),
    options = layersControlOptions(collapsed = FALSE)
  )
```

### Actividad 3

Lee `dat/listings.csv`. Contiene un listado de alojamientos anunciados en AirBnB en Madrid.

Coge aleatoriamente una muestra de 500 alojamientos y píntalos sobre un mapa de Madrid. Cada marcador debe tener un color diferente dependiendiendo del tipo (`room_type`).

```{r}
listings <- read.csv("dat/listings.csv") %>%
  sample_n(500)

paleta_tipo <- colorFactor("Set1", domain = unique(listings$room_type))

leaflet(listings) %>%
  addProviderTiles("CartoDB.Positron") %>%
  setView(lng = -3.69, lat = 40.43, zoom = 12) %>%
  addCircleMarkers(lat = ~latitude, lng = ~longitude, color = ~paleta_tipo(room_type),
                   stroke = FALSE, radius = 2, fillOpacity = 0.5) %>%
  addLegend(
    position = "bottomright",
    pal      = paleta_tipo,
    values   = ~room_type,
    title    = "Tipo de habitación"
  )
```
